package main

import (
	"flag"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"log"
	"os"
	"path"
	"strings"
	"text/template"
)

const tmpl = `package {{.PackageName}}

import (
	"context"
	"database/sql"
)

// DO NOT EDIT
// GENERATED BY go-sql-gen
{{range .Structs}}
// Get{{.Name}}Context returns element of type {{.Name}}.
//
// Get{{.Name}}Context expects the following query fields order:
// {{range $i, $s := .Fields}}{{if gt $i 0}},{{end}}{{$s}}{{end}}
func Get{{.Name}}Context(ctx context.Context, db *sql.DB, query string, args ...interface{}) (result {{.Name}}, err error) {
	err = db.QueryRowContext(ctx, query, args).Scan({{range $i, $s := .Fields}}{{if gt $i 0}}, {{end}}&result.{{$s}}{{end}})
	return result, err
}

// Get{{.Name}}ListContext returns slice of elements of type {{.Name}}.
//
// Get{{.Name}}ListContext expects the following query fields order:
// {{range $i, $s := .Fields}}{{if gt $i 0}},{{end}}{{$s}}{{end}}
func Get{{.Name}}ListContext(ctx context.Context, db *sql.DB, query string, args ...interface{}) (result []{{.Name}}, err error) {
	rows, err := db.QueryContext(ctx, query, args)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	for rows.Next() {
		var item {{.Name}}
		if err := rows.Scan({{range $i, $s := .Fields}}{{if gt $i 0}}, {{end}}&item.{{$s}}{{end}}); err != nil {
			return nil, err
		}
		result = append(result, item)
	}

	return result, err
}
{{end}}
`

var templater = template.Must(template.New("").Parse(tmpl))

func main() {
	log.SetFlags(0)
	log.SetPrefix("go-sql-scan: ")

	fileSuffix := flag.String("suffix", "prefix", "generated file suffix;")

	flag.Parse()

	*fileSuffix = fmt.Sprintf("_%s.go", *fileSuffix)

	args := flag.NArg()
	if args == 0 {
		log.Fatalln("no files provided")
	}

	for i := 0; i < args; i++ {
		fn := flag.Arg(i)

		if !strings.HasSuffix(fn, ".go") || strings.HasSuffix(fn, *fileSuffix) {
			continue
		}

		if err := processFile(fn, *fileSuffix); err != nil {
			log.Printf("couldn't process file %s: %v\n", fn, err)
		}
	}
}

type parsedStruct struct {
	Name   string
	Fields []string
}

func processFile(fname, suffix string) error {
	fs := token.NewFileSet()
	pf, err := parser.ParseFile(fs, fname, nil, parser.ParseComments)
	if err != nil {
		return err
	}

	structs := make([]parsedStruct, 0)
	ast.Inspect(pf, func(n ast.Node) bool {
		t, ok := n.(*ast.TypeSpec)
		if !ok {
			return true
		}

		if t.Type == nil {
			return true
		}

		st, ok := t.Type.(*ast.StructType)
		if !ok {
			return true
		}

		fields := make([]string, 0, st.Fields.NumFields())
		for i := 0; i < st.Fields.NumFields(); i++ {
			fieldName := ""
			if len(st.Fields.List[i].Names) != 0 {
				fieldName = st.Fields.List[i].Names[0].Name
			}

			if fieldName != "" {
				fields = append(fields, fieldName)
			}
		}

		structs = append(structs, parsedStruct{
			Name:   t.Name.Name,
			Fields: fields,
		})

		return true
	})

	result, err := os.Create(strings.Replace(fname, ".go", suffix, 1))
	if err != nil {
		return err
	}
	defer result.Close()

	if err := templater.Execute(result, struct {
		PackageName string
		Structs     []parsedStruct
	}{
		PackageName: path.Dir(fname),
		Structs:     structs,
	}); err != nil {
		return err
	}

	return nil
}
